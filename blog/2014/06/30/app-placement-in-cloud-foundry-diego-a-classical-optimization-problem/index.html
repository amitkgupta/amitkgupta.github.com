
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>App Placement in Cloud Foundry Diego: A Classical Optimization Problem - Amit's Blog</title>
  <meta name="author" content="Amit Kumar Gupta">

  
  <meta name="description" content="I work on the Cloud Foundry Diego team, a project that started as a rewrite of one of the existing Cloud Foundry components, namely the DEA, in Go ( &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://akgupta.ca/blog/2014/06/30/app-placement-in-cloud-foundry-diego-a-classical-optimization-problem">
  <link href="/images/aleph.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Amit's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<!--- MathJax Configuration -->
<script type="text/javascript"
src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,http://drz.ac/javascripts/MathJaxLocal.js">
</script>
<!---Shadowbox Configuration -->
<link rel="stylesheet" type="text/css" href="/stylesheets/shadowbox.css">
<script type="text/javascript" src="/javascripts/shadowbox.js"></script>
<script type="text/javascript">
Shadowbox.init();
</script>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-41581367-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Amit's Blog</a></h1>
  
    <h2>Math, Code, etc.</h2>
  
</hgroup>

</header>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">App Placement in Cloud Foundry Diego: A Classical Optimization Problem</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-30T22:48:00-07:00" pubdate data-updated="true">Jun 30<span>th</span>, 2014</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>I work on the Cloud Foundry <a href="https://github.com/cloudfoundry-incubator/diego-release">Diego</a> team, a project that started as a rewrite of one of the existing Cloud Foundry components, namely the DEA, in Go (hence “Diego”), but evolved into a ground-up rearchitecture of the core service. Our team’s fearless leader <a href="https://twitter.com/onsijoe">Onsi Fakhouri</a> recently <a href="https://www.youtube.com/watch?v=1OkmVTFhfLY">gave a talk</a> explaining the Diego rewrite. Seriously, watch that talk, it might literally be <em>the</em> best engineering talk you’ll ever see.</p>
<p>Onsi talks about the problems associated with having a single component, namely the <a href="https://github.com/cloudfoundry/cloud_controller_ng">Cloud Controller</a>, responsible for knowing about all the apps currently running on all the application executors, known as <a href="https://github.com/cloudfoundry/dea_ng">Droplet Executation Agents</a> or DEAs for short, and orchestrating the placement of newly started apps on a DEA. I want to introduce some of the key players in the Diego architecture and explain the new approach that Diego takes to solve the app placement problem, and to illustrate all this I thought it’d be fun to model the app placement problem as a sort of classical <strong>constrained optimization problem</strong>.</p>
<!--more-->

<p>In what follows, I actually describe a slightly idealized version of Diego. For instance, I take into account the desire to balance apps across multiple clusters of hosts (which are usually physically isolated from one another in some way) to ensure higher availability, which Diego doesn’t currently do. I’ll refer to these clusters as Availability Zones (AZs) to borrow a term from AWS, but everything that follows is IaaS-agnostic.</p>
<h2 id="introducing-diegos-auction">Introducing Diego’s “Auction”</h2>
<p>Most decision problems in optimization research owe their complexity to the size of the input space. The hard part is searching this space for an input which optimizes some objective function, or comes close enough, and doing so in a reasonable amount of time. The approach to these sorts of problems is to find faster and more efficient algorithms.</p>
<p>The app placement problem is rather different. The solution space is rather small – even in a large production Cloud Foundry deployment there may be only 50 application execution VMs to choose from. Most of the complexity here is due to the fact the problem is (a) distributed, and (b) asynchronous. Because it’s a distributed problem we have to take into account that the inputs, objective function, and constraints may be coming from different sources, and that these data need to be communicated between sources in a machine-readable way over network and messaging protocols such as HTTP and <a href="https://github.com/apcera/gnatsd">NATS</a>. Because it’s an asynchronous problem, where we may be simultaneously be attempting to place 20 instances of the same app, we have to take into account that between the time system realizes it needs to make a decision about placing an app instance, and the time it takes action on a decision its made, the input it based its decision on may have changed – indeed, we’d otherwise end up placing all 20 instances on the same execution VM!</p>
<p>Instead of the old model where the Cloud Controller tries to maintain its own copy of the state of the world, we want to gather state from the appropriate sources of truth at decision-time. And we’re going to want to have some confidence that our decision is stable in light of recent changes in the state of the world that may have occurred while we were gathering the state and making the decision. This is accomplished in Diego by holding an “auction”, where application execution VMs “bid” to host an app, and the strength of their bid is determined by several factors, for instance the amount of free memory they have. Let’s understand the auction a little better by looking at the players involved and their responsibilities.</p>
<h3 id="the-cast-of-characters-in-a-diego-auction">The Cast of Characters in a Diego Auction</h3>
<ul>
<li><a href="https://github.com/cloudfoundry-incubator/app-manager"><strong>The App Manager</strong></a>: sits behind the user-facing API, and handles requests to start apps. It knows things about desired apps, such as how many instances of the app are desired to start, where the source code for the app lives (in some blobstore), what the compute requirements are for an instance of the app in terms of memory, disk, and so on. It (eventually) causes app instances to be run by requesting an “auction” to be held where machines bid to run the app.</li>
<li><a href="https://github.com/cloudfoundry-incubator/auctioneer"><strong>The Auctioneer</strong></a>: watches for “start-auction” requests for desired app instances, and then holds the auctions. It gathers “bids” and then chooses a “winner”, and the winner is then responsible for running the app.</li>
<li><a href="https://github.com/cloudfoundry-incubator/executor"><strong>The Executors</strong></a>: form a pool of processes, each running on a separate VM, with each one capable of running multiple apps in isolated containers within its VM.</li>
<li><a href="https://github.com/cloudfoundry-incubator/rep"><strong>The Reps</strong></a>: represent the Executors, one Rep for one Executor. They participate in the auctions, providing bids requested by the Auctioneer on behalf of their Executors. A bid encapsulates relevant information about an Executor, such as what apps its currently running, and how much more free memory it can allocate to new containers.</li>
</ul>
<p>(For more, check out the <a href="https://github.com/cloudfoundry-incubator/diego-design-notes">Diego Design Notes</a>)</p>
<p>So the problem that we’re going to model as a classical optimization problem is that of choosing the winning Rep bid for a particular auction.</p>
<h2 id="a-concrete-use-case">A Concrete Use Case</h2>
<p>Let’s use the example of a user pushing a new app. The user wants to have three instances of it running, so that it’s highly available. Ideally, these instances would be balanced across different Executors running in different AZs. If they all end up in the same AZ, or worse, on the same Executor, then the high availability you’d expect to achieve by running 3 instances is a lot more brittle.</p>
<p>So if we’re to balance instances across AZs, how should we do it? It can’t be as simple as saying, “put instance 0 in the first AZ, instance 1 in the next AZ, etc.” since that’ll clearly skew app placement towards the first AZs and away from the last AZs (in whatever ordering you have for your AZs).</p>
<p>We might try to pick an AZ at random, and then pick an Executor in that AZ at random. But in addition to having their app instances balanced across AZs, the user wants to ensure a certain amount of memory and disk are allocated to each running instance. What if the Executor we chose doesn’t have the resources? Worse, what if the AZ we chose doesn’t have any Executors with enough resources?</p>
<p>So when placing an app instance, we want to place it in an AZ that isn’t already running any instances of our app, or if we’ve asked for more instances than there are AZs, we want to make sure that when placing a particular instance, we place it in an AZ that isn’t already running too many other instances of our app. In addition to that, we want to choose an AZ, and an Executor in that AZ, that has enough free compute resource to run the instance. Finally, if there are several candidate Executors, it’s better to go with the one with the most free resources so as to better balance the load across Executors.</p>
<p>Whether it’s AZs or Executors, balancing the load intelligently hedges against the risk associated with any one of the AZs or Executors going down. The App Manager is going to take data about an <code>AppInstance</code> and trigger a “start-auction”, which will include an <strong>objective function</strong> and <strong>constraints</strong> specific to that <code>AppInstance</code>. The Auctioneer will start the auction and gather <code>RepBid</code>s from the Reps. These <code>RepBid</code>s will constitute the <strong>inputs</strong> for the objective function, and the Auctioneer will find the input which minimizes the objective function amongst those that satisfy the constraints.</p>
<h2 id="the-optimization-problem-deciding-a-diego-auction-winner">The Optimization Problem: Deciding a Diego Auction Winner</h2>
<p>Now let’s actually formally define the problem, the data structures involved, and see what pieces are already in place in Diego that implement solutions and measure the quality of solutions.</p>
<h3 id="data-structures">Data Structures</h3>
<div class='bogus-wrapper'>
<notextile>
<figure class='code'><figcaption>
<span></span>
</figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">type</span> <span class="nx">AppInstance</span> <span class="kd">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">RequiredDiskMB</span>      <span class="kt">uint</span>
</span><span class='line'>  <span class="nx">RequiredMemoryMB</span>    <span class="kt">uint</span>
</span><span class='line'>  <span class="nx">AppID</span>               <span class="kt">uint</span>
</span><span class='line'>  <span class="nx">InstanceNumber</span>      <span class="kt">uint</span>
</span><span class='line'>  <span class="nx">TotalInstances</span>      <span class="kt">uint</span>
</span><span class='line'>  <span class="nx">AppSourceBlobID</span>     <span class="kt">string</span>
</span><span class='line'>  <span class="nx">Stack</span>               <span class="kt">string</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">type</span> <span class="nx">RepBid</span> <span class="kd">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">AvailableMemoryMB</span>   <span class="kt">uint</span>
</span><span class='line'>  <span class="nx">AvailableDiskMB</span>     <span class="kt">uint</span>
</span><span class='line'>  <span class="nx">TotalMemoryMB</span>       <span class="kt">uint</span>
</span><span class='line'>  <span class="nx">TotalDiskMB</span>         <span class="kt">uint</span>
</span><span class='line'>  <span class="nx">RunningAppIDs</span>       <span class="p">[]</span><span class="kt">uint</span>
</span><span class='line'>  <span class="nx">AvailZoneNumber</span>     <span class="kt">uint</span>
</span><span class='line'>  <span class="nx">CachedBlobIDs</span>       <span class="p">[]</span><span class="kt">string</span>
</span><span class='line'>  <span class="nx">Stack</span>               <span class="kt">string</span>
</span><span class='line'><span class="p">}</span>          
</span></code></pre></td></tr></table></div></figure>
</notextile>
</div>
    
<h3 id="problem">Problem</h3>
<p>Choose the “highest-scoring” Rep to run a particular <code>AppInstance</code>:</p>
<p><span class="math">\[ \argmax _r f_{\mathrm{AM},ai}(r) \]</span></p>
<p>where <span class="math">\(f_{AM,ai}\)</span> is the objective function for the <code>AppInstance</code> provided by the <span class="math">\(\mathrm{AM}\)</span> (App Manager), and <span class="math">\(r\)</span> ranges over all the <code>RepBid</code>s collected by the Auctioneer from the Reps.</p>
<h3 id="constraints">Constraints</h3>
<p>A Rep’s bid is only feasible if its Executor has enough memory and disk, and is running the same stack (e.g. Lucid 64-bit) as required for the <code>AppInstance</code>:</p>
<p><span class="math">\[r.AvailableMemoryMB \geq ai.RequiredMemoryMB \]</span> <span class="math">\[r.AvailableDiskMB \geq ai.RequiredDiskMB \]</span> <span class="math">\[r.Stack = ai.Stack \]</span></p>
<h3 id="actual-problem">Actual Problem</h3>
<p>The <strong>actual</strong> problem is to express an objective function that captures the business requirements, and then find a near-optimal solution efficiently. Furthermore, any solution must take into account that the data in a Rep’s bid can change in the course of an auction it’s participating in, since it may be participating in multiple simultaneous auctions. For instance, a Rep might report having 4096MB free memory simultaneously in many different auctions. If it wins one of the auctions and agrees to start a 512MB app instance, then its original bid in any of the auctions that haven’t been decided yet is based on old information, since it now only has 3584MB free.</p>
<h3 id="meta-constraints">Meta-Constraints</h3>
<p>The objective function <span class="math">\(f_{\mathrm{AM},ai}\)</span> itself must be expressible in terms of <span class="math">\(ai\)</span> and <span class="math">\(r\)</span> in a fairly simple way. Here are some meta-constraints on the expression used to define the function by allowing only the following operations:</p>
<ul>
<li><strong>Attributes:</strong> Access public attributes of <span class="math">\(r\)</span> and <span class="math">\(ai\)</span>.</li>
<li><strong>Arithmetic:</strong> <span class="math">\(+, \times, \div, \mathrm{mod}\)</span> where the modulus for <span class="math">\(\mathrm{mod}\)</span> must be a constant, not a computed value.</li>
<li><strong>Counting:</strong> <code>count(x, xs)</code> which counts how many times <code>x</code> occurs in the slice <code>xs</code>.</li>
</ul>
<p>It’s not terribly important what the exact constraints are, they just need to be strict enough to ensure that a very simple DSL will suffice to express the objective function. Nobody wants to be sending arbitrary expressions involving <span class="math">\(ai\)</span> and <span class="math">\(r\)</span> from the App Manager to be <code>eval</code>ed on the Auctioneer.</p>
<h3 id="a-proposal-for-the-objective-function">A Proposal for the Objective Function</h3>
<p><span class="math">\[ f_{\mathrm{AM},ai}(r) = (ai.InstanceNumber + ai.AppID + r.AvailZoneNumber)(\mathrm{mod}\  \# AZs) + 1\]</span> <span class="math">\[ +\ \alpha \cdot \mathrm{count}(ai.AppSourceBlobID, r.CachedBlobIDs)\]</span> <span class="math">\[ +\ \beta \cdot (r.AvailableMemoryMB / r.TotalMemoryMB)\]</span> <span class="math">\[ +\ \gamma \cdot (r.AvailableDiskMB / r.TotalDiskMB) \]</span> <span class="math">\[ +\ \delta \cdot (1 - \mathrm{count}(ai.AppID, r.RunningAppIDs) / ai.TotalInstances) \]</span></p>
<p>where <span class="math">\(\# AZs\)</span> is the total number of AZs, and <span class="math">\(\alpha, \beta, \gamma, \delta\)</span> are non-negative weighting constants that add up to <span class="math">\(1\)</span>.</p>
<p>Let me explain:</p>
<ol type="1">
<li>The first line deserves some detailed explanation.<br /></li>
</ol>
<ul>
<li>For starters, let’s ignore the ai.AppID term. Then the expression that remains <strong>ensures that each instance of an app gives preference to a different AZ</strong>. For example, suppose there are four AZs, and so each <code>RepBid</code> has an <code>AvailZoneNumber</code> of <span class="math">\(1\)</span>, <span class="math">\(2\)</span>, <span class="math">\(3\)</span>, or <span class="math">\(4\)</span>. Then for instance <span class="math">\(0\)</span> the first term (ignoring <span class="math">\(ai.AppID\)</span>) is maximized when the <code>Rep</code> is on AZ <span class="math">\(3\)</span>. For instance <span class="math">\(1\)</span>, it’s maximized when <code>r.AvailZoneNumber</code> is <span class="math">\(2\)</span>. For instances <span class="math">\(3\)</span> and <span class="math">\(4\)</span>, the preferred AZ will be <span class="math">\(1\)</span> and <span class="math">\(4\)</span>, respectively. And then it repeats. So if an instance <span class="math">\(4\)</span> is requested, it’ll prefer to be on AZ <span class="math">\(3\)</span>, just like instance <span class="math">\(0\)</span>.</li>
<li>This expression doesn’t merely pick out a preferred AZ for each instance, it determines a complete preference ranking of all the AZs. Instance <span class="math">\(0\)</span> prefers AZs <span class="math">\(3\)</span>, <span class="math">\(2\)</span>, <span class="math">\(1\)</span>, and <span class="math">\(4\)</span>, in that order. That way if there are no <code>RepBid</code>s coming from a preferred AZ, there is some deterministic way to decide amongst the rest.</li>
<li>Recall earlier that wanted to avoid making the same AZ placement for instance 0 of every app, since that AZ would quickly become overwhelmed. This is where <span class="math">\(ai.AppID\)</span> comes in. The <span class="math">\(ai.AppID\)</span> term effectively shifts the AZ-preference order for each <code>AppInstance</code> by <span class="math">\(ai.AppID\ (\mathrm{mod}\ \# AZs)\)</span>. Assuming that <span class="math">\(ai.AppID\)</span> are sufficiently randomly distributed, we’d expect that a quarter of all applications’ <span class="math">\(0^{\mathrm{th}}\)</span> instance will prefer AZ <span class="math">\(1\)</span>, and likewise a quarter for AZs <span class="math">\(2\)</span>, <span class="math">\(3\)</span>, and <span class="math">\(4\)</span>.</li>
<li>Finally, since the result of the modulo is an integer, and then we add <span class="math">\(1\)</span>, and then the rest adds up to <span class="math">\(\alpha + \beta + \gamma + \delta = 1\)</span> at best, we’re assured that balancing instances across AZs is the “most-significant bit”“, and is given highest consideration compared to any other feature of a <code>RepBid</code>, such as free memory.<br /></li>
</ul>
<ol start="2" type="1">
<li>The second line gives some weight to an <strong>Executor that has a cached copy of the app’s source</strong> locally. The <span class="math">\(\mathrm{count}\)</span> expression on that line will only ever evaluate to <span class="math">\(0\)</span> or <span class="math">\(1\)</span>.<br /></li>
<li>The third line considers the <strong>percentage of free memory on an Executor</strong>.<br /></li>
<li>And the fourth considers the <strong>percentage of free disk</strong>.<br /></li>
<li>The fifth line takes into account <strong>how many instances of the app the Executor is already running</strong>. So, for instance, if two Reps are “tied” before considering this criteria, both have the same percentage of Memory and Disk free, but one of them is already running many instances of the app, it would be preferable to put the current instance in question on the other Executor.</li>
</ol>
<p>Note: to implement that function in Golang most things will have to be typecast to <code>float64</code>. Not only for the division, turns out Go wants floats for <a href="http://golang.org/src/pkg/math/mod.go"><span class="math">\(\mathrm{mod}\)</span></a> as well.</p>
<p>Solutions to this optimization problem have to be evaluated based on time taken, CPU and memory cost, number of network calls, how well-balanced it places apps, and all in the context of being run multiple times concurrently.</p>
<h2 id="what-diego-already-does-and-where-its-headed">What Diego Already Does, and Where It’s Headed</h2>
<p>Diego already runs auctions. Not only that, the <a href="https://github.com/cloudfoundry-incubator/auction/tree/master/auctionrunner">auctionrunner</a> package already defines multiple ways to run an auction. There are auctions such as <a href="https://github.com/cloudfoundry-incubator/auction/blob/master/auctionrunner/random.go">randomAuction</a> which optimizes for performance but obviously does miserably at choosing a near-optimal, feasible <code>RepBid</code>. Other auctions make tradeoffs between quality of the <code>RepBid</code> it chooses, total number of communications, etc. Any one of these auctions can be run in a multi-round format, where a winner is tentatively selected but multiple rounds are played, to adjust for the fact that a Rep’s bid can quickly become invalid if it’s participating in multiple auctions.</p>
<p>What’s currently missing is the elaboratness of the objective function. Diego does not take AZ placement or cached blobs into account, as though the first two lines on the right-hand side of the equation weren’t there. It also weighs free memory, disk, and currently running apps equally, as though <span class="math">\(\beta = \gamma = \delta = 1/3\)</span>).</p>
<p>Moreover, the objective function is not currently something dynamic. In fact, the Auctioneer has no notion of an objective function, and Rep bids aren’t structured objects. The Reps compute the scores and just give those scores directly to the Auctioneer, and the formula for computing scores is <a href="https://github.com/cloudfoundry-incubator/auction/blob/master/auctionrep/auction_rep.go#L238-L247">hard-coded</a>.</p>
<p>AZ balancing is <a href="https://www.pivotaltracker.com/story/show/70403224">in the backlog</a>! <a href="https://www.pivotaltracker.com/story/show/70403278">Another cool feature</a> we have planned is periodic rebalancing based on CPU usage (for starters). Placing apps in a balanced manner when starting new instances is all well and good, but over time, app placement may become less balanced. For instance, if an AZ goes down, all the instances on it will be evacuated and re-run in different AZs. When that AZ comes back up, we’d like to gradually move some instances back there.</p>
<h2 id="how-to-evaluate-and-prosose-solutions-for-diego">How to Evaluate and Prosose Solutions for Diego</h2>
<p>Diego has a <a href="https://github.com/cloudfoundry-incubator/auction/tree/master/simulation">Simulator</a>! You can run the simulator on its own, and it also runs as part of the test suite. You can play with all sorts of different variables in the system. For instance, you can obviously run different types of auctions (random vs. pick-the-best). But you can also play around with different communication modes, e.g. in-process vs. NATS, to see how performance is affected when the communication between processes is “realistically” handled by a central message bus.</p>
<p>Simulation runs are accompanied by a report that will show up in your browser. Reports include statistics, so you can evaluate things such as total number of communications and standard deviation in the number of apps placed on each Executor, and visualizations, so you can see how well the apps were balanced or how many rounds were required to pick an auction winner. Here’s what the output looks like in the browser and the terminal:</p>
<div style="margin:auto">
<a href="/images/simulation_browser.png" rel="shadowbox"><img src="/images/simulation_browser.png" width="40%" height="40%" style="vertical-align: middle"></a> <a href="/images/simulation_terminal.png" rel="shadowbox"><img src="/images/simulation_terminal.png" width="40%" height="40%" style="vertical-align: middle"></a>
</div></div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Amit Kumar Gupta</span></span>

      








  


<time datetime="2014-06-30T22:48:00-07:00" pubdate data-updated="true">Jun 30<span>th</span>, 2014</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://akgupta.ca/blog/2014/06/30/app-placement-in-cloud-foundry-diego-a-classical-optimization-problem/" data-via="" data-counturl="http://akgupta.ca/blog/2014/06/30/app-placement-in-cloud-foundry-diego-a-classical-optimization-problem/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/06/21/k-nn-algorithm-in-golang-and-haskell/" title="Previous Post: k-NN Algorithm in Golang and Haskell">&laquo; k-NN Algorithm in Golang and Haskell</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Contact</h1>
  <p>Twitter: <a href="https://twitter.com/amitkgupta84/">@amitkgupta84</a><br>
     LinkedIn: <a href="http://www.linkedin.com/pub/amit-gupta/1a/527/936">Amit Kumar Gupta</a></p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/06/30/app-placement-in-cloud-foundry-diego-a-classical-optimization-problem/">App Placement in Cloud Foundry Diego: A Classical Optimization Problem</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/21/k-nn-algorithm-in-golang-and-haskell/">k-NN Algorithm in Golang and Haskell</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/06/07/so-you-still-dont-understand-hindley-milner-part-3/">So You Still Don't Understand Hindley-Milner? Part 3</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/06/07/so-you-still-dont-understand-hindley-milner-part-2/">So You Still Don't Understand Hindley-Milner? Part 2</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/06/06/entropy-how-password-strength-is-measured/">Entropy: How Password Strength Is Measured</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/06/02/yo-dawg/">Yo Dawg, I Herd You Like Math</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/19/is-it-possible-to-be-15-percent-swedish/">Is It Possible to Be 15% Swedish?</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/14/so-you-still-dont-understand-hindley-milner/">So You Still Don't Understand Hindley-Milner? Part 1</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/11/setting-up-postgresql-with-macports-for-ruby-on-rails-development/">Setting Up PostgreSQL With MacPorts for Ruby on Rails Development</a>
      </li>
    
  </ul>
</section>


  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Amit Kumar Gupta -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'amitsblog-math-code';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://akgupta.ca/blog/2014/06/30/app-placement-in-cloud-foundry-diego-a-classical-optimization-problem/';
        var disqus_url = 'http://akgupta.ca/blog/2014/06/30/app-placement-in-cloud-foundry-diego-a-classical-optimization-problem/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
